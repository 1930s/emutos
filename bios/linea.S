/*
 * linea.S - linea graphics stuff 
 *
 * Copyright (c) 2001 by Authors:
 *
 *  MAD  Martin Doering
 *  THO  Thomas Huth
 *
 * This file is distributed under the GPL, version 2 or at your
 * option any later version.  See doc/license.txt for details.
 *
 */

// ===========================================================================
// ==== 
// ===========================================================================
//
// Copyright (c) 2001 Martin Doering.
//
// Authors:
//  MAD  Martin Doering
//
// This file is distributed under the GPL, version 2 or at your
// option any later version.  See doc/license.txt for details.
//



// ==== Defines ==============================================================

//
//       font header structure equates.
//

        .equ    FIRST,          36
        .equ    LAST,           38
        .equ    CEL_WD,         52
        .equ    POFF,           72
        .equ    PDAT,           76
        .equ    FRM_WD,         80
        .equ    FRM_HT,         82

// ==== External Declarations ================================================

        .global _con_state_init  	// initialize linea graphics subsystem
        .global _int_linea       	// entry for linea exception
        .global _font_init       	// cursor initialisation
        .global _cur_init       	// cursor initialisation
        .global _color_init       	// color initialisation
        .global _resol_set       	// set screen resolution
        .global _clear_screen       	// do it!

// ==== References ===========================================================

        .xdef   _f8x8           // font header
        .xdef   _f8x16          // font header
        .xdef   sshiftmod       // mode/bits of shift/modifyer keys

        .xdef normal_ascii      // start with default function


// ==== Line-A handler ===============================
_int_linea:
	move.l  2(sp),a0
	move.l  a0,a1
	clr.l   d0
	move.w  (a0)+,d0
	move.l  a0,2(sp)
	and.w   #0xFFF,d0
	tst.w   d0
	bmi     wrong_linea
	cmp.w   linea_ents,d0
	bpl	wrong_linea
	lea     linea_vecs,a0
	lsl.w   #2,d0
	move.l  0(a0,d0),a0
	jsr     (a0)
linea_dispatch_pc:	
	rte

wrong_linea:
	move.w  d0,-(sp)
	sub.w   #2,a0
	move.l  a0,-(sp)
	pea	wrong_linea_msg
	jsr     _kprintf
	add.w	#10,sp
	rte
wrong_linea_msg:	
	.ascii  "pc=0x%08lx: Line-A call number 0x%03x out of bounds\n\0"
	.even



_linea_0:	
	lea	line_a_vars,a0  // get base address for line a variables
	move.l  a0,d0

	move.l  font_ring,a1	// get pointer to the three system font headers
	move.l  (a1),a1
	
	lea     linea_vecs,a2	// get pointer to table of the Line-A routines
	rts

//
// These are stubs for linea :
// the stub will print the pc of the caller, whether the function
// was called using the line a opcode, or directly via its address.
//

_linea_1:
	move.w	#1,d0
	bra	linea_stub



_linea_2:
	move.w	#2,d0
	bra	linea_stub



_linea_3:
	move.w	#3,d0
	bra	linea_stub



_linea_4:
	move.w	#4,d0
	bra	linea_stub



_linea_5:
	move.w	#5,d0
	bra	linea_stub



_linea_6:
	move.w	#6,d0
	bra	linea_stub



_linea_7:
	move.w	#7,d0
	bra	linea_stub



_linea_8:
	move.w	#8,d0
	bra	linea_stub



_linea_9:
	move.w	#9,d0
	bra	linea_stub



_linea_a:
	move.w	#0xa,d0
	bra	linea_stub



_linea_b:
	move.w	#0xb,d0
	bra	linea_stub



_linea_c:
	move.w	#0xc,d0
	bra	linea_stub



_linea_d:
	move.w	#0xd,d0
	bra	linea_stub



_linea_e:
	move.w	#0xe,d0
	bra	linea_stub



_linea_f:
	move.w	#0xf,d0
	bra	linea_stub



linea_stub:
	move.l  (sp),d1
	sub.l   #linea_dispatch_pc,d1
	and.l   #0xFFFFFF,d1
	bne	1f
	move.l  a1,a0
	bra     2f
1:	move.l  (sp),a0
2:	move.w  d0,-(sp)
	move.l  a0,-(sp)	
	pea	linea_stub_msg
	jsr	_kprintf
	add.w	#10,sp
	rts
linea_stub_msg:
	.ascii	"pc=0x%08lx: unimplemented Line-A call number 0x%03x\n\0"
	.even
	


linea_vecs:
	dc.l	_linea_0
	dc.l	_linea_1
	dc.l	_linea_2
	dc.l	_linea_3
	dc.l	_linea_4
	dc.l	_linea_5
	dc.l	_linea_6
	dc.l	_linea_7
	dc.l	_linea_8
	dc.l	_linea_9
	dc.l	_linea_a
	dc.l	_linea_b
	dc.l	_linea_c
	dc.l	_linea_d
	dc.l	_linea_e
	dc.l	_linea_f
linea_ents:
	dc.w    (linea_ents-linea_vecs)/4



/*
 * _font_init - font globals initialization
 *
 * Initialize the fonts
 *
 * input:
 *   (sp) = ptr to system font header
 */

_font_init:
	move.l  4(sp),a0
        lea     _f8x16, a0              // Get pointer to 8x16 font header
        move    FRM_HT(a0),d0           // fetch form height.
        move    d0,v_cel_ht             // init cell height.
        move    _v_lin_wr,d1            // fetch bytes/line.
        mulu    d0,d1
        move    d1,v_cel_wr             // init cell wrap.
        moveq.l #0,d1
        move    v_vt_rez,d1             // fetch vertical res.
        divu    d0,d1                   // vert res/cell height.
        subq    #1,d1                   // 0 origin.
        move    d1,v_cel_my             // init cell max y.
        moveq.l #0,d1
        move    v_hz_rez,d1             // fetch horizontal res.
        divu    CEL_WD(a0),d1           // hor res/cell width.
        subq    #1,d1                   // 0 origin.
        move    d1,v_cel_mx             // init cell max x.
        move    FRM_WD(a0),v_fnt_wr     // init font wrap.
        move    FIRST(a0),v_fnt_st      // init font start ADE.
        move    LAST(a0),v_fnt_nd       // init font end ADE.
        move.l  PDAT(a0),v_fnt_ad       // init font data ptr.
        move.l  POFF(a0),v_off_ad       // init font offset ptr.

        rts



/*
 * _con_state_init - initialize the conout state machine
 */

_con_state_init:
        move.l  #normal_ascii, con_state // Init conout state machine

        rts



/*
 * _color_init - initialize the system colors
 */

_color_init:
        move.w  #-1, v_col_fg           // foreground color := 15.
        move.w  #0, v_col_bg            // background color := 0.

        rts



/*
 * _cur_init - initialize the vt52 cursor
 */

_cur_init:
        moveq.l #0, d0
        move.w  d0, v_cur_cx            // cursor column 0
        move.w  d0, v_cur_cy            // cursor line 0
        move.w  d0, v_cur_of            // line offset 0
        move.l  _v_bas_ad, a0           // get base address of screen
        move.l  a0, v_cur_ad            // home cursor.
        move.b  #1, v_stat_0            // invisible, flash, nowrap, normal video.
        move.b  #30, v_cur_tim          // .5 second blink counter (@60 Hz vblank).
        move.b  #30, v_period           // .5 second blink rate (@60 Hz vblank).
        move.w  #1, disab_cnt           // cursor disabled 1 level deep.
	
        rts



/*
 * _clear_screen - Clear the screen
 */
 
_clear_screen:
        move.w  v_col_bg, d0            // load background color
        move.l  _memtop, a0             // Set start of RAM
scr_loop:
        move.w  d0, (a0)+               // set to background color
        cmp.l   _phystop, a0             // End of BSS reached?
        bne     scr_loop                // if not, clear next word

        rts


/*
 * resol_set - set video resolution
 */

_resol_set:
	move.w  4(sp), d0               // get video mode
        moveq.l #0, d1                  

        move.b  splanes(pc, d0.w), d1   // Get the number of planes
        move.w  d1, _v_planes           // save it

        move.b  sbytes(pc, d0.w), d1    // Get the number of bytes per line
        move.w  d1, _v_lin_wr           // Set the line wrap

        asl.w   #1, d0                  // resolution as word index
        move.w  sresoly(pc, d0.w), d1   // Get the vertical resolution
        move.w  d1, v_vt_rez            // Set it

        move.w  sresolx(pc, d0.w), d1   // Get the horizontal resolution
        move.w  d1, v_hz_rez            // Set it

        rts


// ==== screenpar - Screen parameters ========================================

splanes:
        dc.b    4,2,1                   // count of color planes (_v_planes)
sbytes:
        dc.b    160,160,80              // bytes per line (_v_lin_wr)
sresoly:
        dc.w    200,200,400             // screen vertical resolution (v_vt_rez)
sresolx:
        dc.w    320,640,640             // screen horiz resolution (v_hz_rez)
        

// ===========================================================================
// ==== End ==================================================================
// ===========================================================================

	.end
        