<head>
  <title>9. System Function Calls</title>
</head>

<body>
10. BIOS Function Calls



10.1. Parameter Format In Memory



To preserve system security and integrity.

 the BIOS is callable only from supervisor mode.

Applications that use the BIOS should follow

these conventions. shown below in C:



return_value = trapl3(function_number,

                           parameter_1,

                           parameter_2, ...);



where 'trapl3' is defined as:



       trapl3:

       move,l     (sp)+,retsave

       trap     #13

       move,l     retsave,-(sp)

       rts



The parameters will then be on the stack in the form:

    ...

    parameter_2

    parameter_1

    WORD    function number

   LONG    PC

   WORD    status register



10.2. BIOS Initialization Sequence



Initialize exception vectors.

Disable interrupts.

Perform osinit().

Enable interrupts.









BIOS Calls                     page 80           Bios Calls page  00



10.3. 00



         VOID get_mpb(p_mpb)

           MPB *p_mpb;

                       {

                       }



Upon entry. p_mpb points to a 'sizeof(MPB)' byte block

to be filled in with the system initial Memory Parameter

Block. Upon return. the MPB is filled in.



Formats are as follows:



MPB /* memory partition block */

     {

      MD     *mp_mfl ;    /* Point to MD described below */

      MD     *mp_mal;    /* 0L */

      MD     *mp_rover;  /* Point to same MD as mp_mfl */

      };



MD /* memory descriptor */  /* Only 1 allowed in first release */

      {

        MD      *mlink;    /* 0L */

        long    *m_start;    /* Beginning address of free memory */

        long    *m_length;   /* Number of bytes of free memory */

        PD      *m_own;     /* 0L */

     };









BIOS Cells            page 81                                   01



10.4. 01



LONG

character_input_status(h)

WORD h;

          {

          }



h  is a character device handle that specifies one

    of the following devices:



        0      PRN:

        1      AUX:

        2      CON:



Returns status in D0.L:

  -1    device is ready

   0    device is not ready









BIOS Calls                page 82         02



10.5. 02



LONG character_input(h)

         WORD h;



              h        is a character device handle described in Function 01.



This function does not return until a character has been input.

It returns the character value in D0.L, with the high word set to zero.



For CON:. it returns the GSX 2.0 compatible scan code in the low

byte of the high word. and the ASCII character in the lower byte,

or zero in the lower byte If the character is non-ASCII



For AUX:, it returns the character in the low byte.









BIOS Calls         page  83                                   03



10.6. 03



VOlD

character_output(h, char)

WORD h, char;

       {

       }



h      is a character device handle described in Function 01.

char       is a character in the low 8 bits of the word.



This function does not return until the character has been output.



C









BIOS Calls       page 84             03



10.7. 04



LONG read_write_sectors(wrtflg. buffer, num. recn. drive)

       WORD wrtfig;

       char *buffer:

       WORD num;

       WORD recn;

       WORD drive;

        {

        }



     wrtflg   is $0 for read, $1 for write

     buffer   is a long pointer to a byte address

                for the disk transfer

     num      is the number of sectors to transfer

     recn     is the beginning record number to transfer

     drive    is 0 for drive A, 1 for drive B.



Function returns a 2's complement error number in D0.L.



It is the  responsibility of the driver to check for media  change

before any write to FAT sectors. If media has changed,

no write should take place. just return with error code.









BIOS Calls       page 85                                                05



10.8. 05



 LONG setexception_vector(vecnum, vecadr)

         WORD vecnum;

         LONG vecadr;

                 {

                 }



vecnum   is the number of the exception vector to get or set

vecadr     is the long address to set into the exception vector table.

       No set is done if vecadr is -1.



Vectors 0x00 - 0xFF are defined by the 68000 hardware.

GEM DOS has defined extended vectors as follows:



0x100       Timer Tick

0x101        Critical Error Handler

0x102       Terminate Handler

0x103 - 0x1FF  Reserved for future use by GEM DOS

0x200 - 0x2FF  Reserved for user defined vectors



Function returns a long address that was the previous entry.



Notes on handling extended vectors:



0x100  Timer Tick



It is the responsibility of the BIOS to save all registers before

it starts down this chain. There is 1 parameter on the stack;

a WORD value of the number of milliseconds since the last

tick. It is the responsibility of the handler that installs itself

to jump to the previous handler in this vector.



0x101  Critical Error Handler



It  is the responsibility of the  handler that installs

itself to save d3-d7/a3-a6 if they are used. The error

number is a WORD parameter on the stack.



To ignore an error, set D0.L to 0. To retry, set D0.L to 0x10000.

To abort, move parameter to D0 and sign extend it to a longword.













BIOS Calls           page 86         05



0x102  Terminate Handler



It is the responsibility of the handler that installs itself to

determine whether it should allow the termination to continue.

To terminate. simply RTS. Otherwise. "longjump"

back to the top of the application that installed the handler.











BIOS CaIls        page  87     05



10.9. 06



LONG get_timer_ticks()

                 {

                 }



Returns the nearest number of milliseconds per tick in D0.L.









BIOS Calls     page 88       06



10.10. 07



BPB "getbpb(d)

      WORD d;

       {

       }



       d       is 0 for drive A. 1 for drive B....



Returns a pointer to the BIOS Parameter Block for the

specified drive in D0.L If necessary. it should read boot

header information from the media in the drive to determine BPB values.



<hr>





BIOS Calls      page 89   08



10.11. 08



LONG character_output_status(h)

        WORD h;

            {

            }



    h   is a character device handle described in Function 01.



Returns status in D0.L:

      -1     device is ready

       0     device is not ready









BIOS Cells                             90       08



10.12. 09



LONG mediachange(d)

      WORD d:

               {

                }



       d        is 0 for drive A. 1 for drive B....



Returns media change status for specified drive in D0.L:



    0     Media definitely has not changed

    1     Media may have changed

    2     Media definitely has changed









BIOS Calls     page 91     09



10.13. 0A



LONG get_drive_map()



h returns a longword containing a bit map of logical drives

in the system with bit 0, the least significant bit,

corresponding to drive A.



Note: lf the BIOS supports logical drives A and B

on a single physical drive. it should return both bits set

if a floppy disk is present.









11. the GEM-GSX Graphical lnterface



The GEM-GSX graphics interface is documented in the

manual set shipped with Digital Research's GEM product.

Please refer to that documentation set for further Information.



           Multi-Tasking



two multitasking schemes are proposed. Both mantain complete

process models in memory. Both types can exist concurrently

within the system



The first type of multitasking  is a background activity (such as

communications or printer spooling) that is interrupt driven and

requires only a small percentage of the total processing time.

such tasks can run concurrently with a foreground process.

Only one background process can run at any given time.



The second type of multitasking allows two or more processes

in the foreground at once with all processes suspended but the

one In the active window.  the active window it defined by the

cursor position - moving the cursor from one window to another

freezes the process the cursor leaves and activates the one it

enters. When activated, a process retrieves an interask

Communication from a designated pipe or queue. The number

of applications running in this mode are limited only by available memory.



           Real Time Response



the design goal for handling real-time Interrupts and exception requests

is  100 rnicroseconds or less. This response speed supports foreground

communications applications running at XXX baud.  (19K baud)





</pre>
</body>
</html>

